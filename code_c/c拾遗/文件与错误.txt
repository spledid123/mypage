#include<stdio.h>
#include<stdlib.h>
int main(){
	FILE *fp;//文件指针类型
	if ((fp = fopen("test.txt","w+")) == NULL){
	//fopen打开文件 (文件名，类型)，返回文件地址，文件名支持相对/绝对路径 
	//类型：1、末尾加b,操作二进制文件
	//		2、r只读（必须存在）r+:读和写，必须存在
	//		3、w只写，不存在创建；w+读写，不存在创建，存在覆盖；//从开头 
	//		4、a追加，不存在创建； a+读和追加，不存在创建，存在追加 
    //文本模式/二进制区别主要是换行符 
		printf("打开test.txt文件失败！");
		exit(EXIT_FAILURE);//abort()//终止异常程序
	//exit 函数用于立即终止当前进程的执行。exit 函数将检查文件的打开情况，并把文件缓冲区的内容写回文件后再关闭文件。
	//要求使用 0 或宏 EXIT_SUCCESS 来表示程序正常终止；而使用宏 EXIT_FAILURE 表示程序非正常终止。 
	} 
	////////////////////////////////////////////////////////////////////字符/字符串 
	char a = 'a';
	fputc(a,fp);
	//fputc,向文件写入单个字符，光标移动，至少txt支持的是char，输入int直接打开乱码 ，失败返回EOF/-1 
	char so[10]="asdf\n";
	fputs(so,fp);
	//fputs,输入字符串(字符串指针,fp),光标移动，最多写入size-1个字符；失败返回EOF 
	/////////////////////////////////////////////////////////////////////////////////格式化 
	fprintf(fp,"%s",so);//格式化向文件写入 
	//////////////////////////////////////////////////////////////////////////////////文件位置计算与随机读取 
	long int i=ftell(fp);printf("%ld\n",i);//ftell返回当前光标位置，用long int 存储，在windows中'\n'占2个位置（1个字节
	rewind(fp);//将光标移到文件头 
	fseek(fp,i,0);//光标偏移函数，5代表向右偏移字节数， 第三个参数，0文件头开始，1当前，2文件末尾 
	//对于第二个参数，由于不同系统对于'\n'的计算不同，最好用由ftell计算的数 
	/////////////////////////////////////////////////////////////////////////////////
	fwrite(&a, sizeof(a), 1, fp);
	//将指定尺寸的数据写入到指定的文件中,光标移动 
	//指针，每个元素的大小，元素个数，文件指针 
	//返回个数 ，若小于1，可能文件损坏 
	fclose(fp);//关闭文件
	/////////////////////////////////////////////////////////////////////
	
	
	
	 
	if ((fp = fopen("test.txt","r")) == NULL){
		printf("打开test.txt文件失败！");
		exit(EXIT_FAILURE); 
	} 
	//////////////////////////////////////////////////////////////////////字符/字符串 
	printf("%c\n",fgetc(fp));//fgetc,文件读取单个字符进入缓冲区，文件光标移动本身不会将数据送入标准输出流,失败返回EOF/-1  
	char s[10];
//	while(!feof(fp)){//eof指示器没有改变返回0，此处表示文件结束 
	fgets(s,10,fp);//}
	printf("%s\n",s);
	//fgets,(字符串指针,字符个数包括'\0',fp),读取字符串到对应指针 ,光标移动，读取失败/文件字符不够 返回NULL,
	//若读取不到任何字符就遇到EOF,返回NULL,当然eof也会改变 
	//若读取到EOF,则eof指示器被设置，可用feof进行判断 
	//遇到'\n'/EOF自动结束一次读取 
	///////////////////////////////////////////////////////////////////格式化 
	fscanf(fp,"%s",s); //格式化读取，移动光标 
	printf("%s\n",s);
	/////////////////////////////////////////////////////////////////////
	char d[10]; 
	fread(d,sizeof(char),10,fp);//返回个数 ，若小于10，可能文件损坏或结尾 
	printf("%s",d);
	fclose(fp);
	return 0; 
}
/*输出： 13
a
asdf

asdf

a*/







#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<errno.h>
//stdin/stdout/stderr
int main(void){
	FILE *fp;
	if ((fp = fopen ("test1.txt","r")) == NULL){
		fputs ("not exist the file !",stderr);
	//int ungetc(int char, FILE *stream)把字符 char（一个无符号字符）推入到指定的流 stream 中，	//以便它是下一个被读取到的字符。
		printf("原因：%d\n",errno);//记录文件错误原因，错误码
		perror("");//在stdio.h头文件，直接原因 
		fprintf(stderr,"%s",strerror(errno)); 
		exit(EXIT_FAILURE);
	}
	fputc('a',fp);
	if (ferror(fp)){//判定是否发生错误 
		fputs("error!",stderr);
	}
	clearerr(fp);//认为清除eof指示器与error指示器的状态
	 if (ferror(fp) || feof(fp)){//判定
		fputs("error!",stderr);
	}
	fclose(fp); 
} 
 
