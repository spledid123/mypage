/*概念：树是一对多关系，存在唯一一个k0没有前驱称为根 ，其他元素有且只有一个前驱；
<x,y>x为父节点，y为子节点，关系为边；
兄弟：有同一个父节点；祖先：y在以x为根的子树中，称 x为x的祖先，y为x的子孙；
路径：x->y的路径，/路径长度
层数：根节点为0，子节点比父节点大1；深度/高度，树的最大层数；
度数，节点的子节点个数；树的度数：max(度数) 
树叶：度数为0的节点；分支：度数大于0；
 有序树/无序树：兄弟节点左右有顺序 
 
 二叉树分类1、空集；2、只有一个根；3、只有根和左子树/右子树；4、两边子树都有 
 满二叉树：任何节点节点为0/2；完全二叉树：只有最下面两层度数可以小于2，且最后一层的节点集中于最左边（堆排序）
 扩充二叉树：把原二叉树所有节点度数扩充为2->新的满二叉树； 外部节点：新添；内部节点，原有节点
 
 二叉树性质：1、非空二叉树第i层最多有2^i个节点；
 2、深度为k的二叉树最多有2^(k+1)-1个节点；
 3、具有n个节点的完全二叉树深度为[log2 n];
 4、对一个完全二叉树根节点定为1，从上到下从左到右排序编号，对i节点，若i==1,为根节点；i>1,父节点为[i/2]
 2i<=n,则左子节点为2i；2i>n,没有左子节点；
 2i+1<=n,右子节点为2i+1,2i+1>n,没有右子节点；
 5、对一个非空二叉树，叶结点个数为n0，度为2的结点个数为n2，则有n0 = n2 + 1 ；
 6、满二叉数：叶节点比分支节点多1；
 7、在扩充的二叉树里，新增加的外部结点的个数比原来的内部结点个数多1
 8、对任意扩充二叉树，E和I之间满足以下关系：E = I + 2n，其中n是内部结点个数 ，E为外部路径长度，I是内部路径长度；
 
 存储1、顺序存储，子节点为（2i+1）（2i+2）,非完全二叉树可以加上空节点存为完全二叉树；
 2、链式存储：(left(左边的子节点) info right)
 
 周游算法：1、深度优先（递归）：后根/中根/前根周游   post(p){post(left);post(right) visit p;} / post(p){post(left);visit p；post(right)} 
 / post(p){visit p;post(left);post(right)} 
 最好O(log2 n);最坏O(n)
 对应后缀/中缀/前缀表达式；
 中+前/后可以推出原二叉树 
 2、广度优先： 从上到下从左到右；
 根节点送入队列->取出队首->将其左节点送入队->将其右节点入队->将队首取出  循环
 
 建立二叉树，为确保任一周游算法结果能还原原二叉树，可以引入一个特殊数据结构->用特殊节点扩充二叉树 */ 
 /*二叉搜索树：一棵树，或者是空树，或者满足，若一个节点为K,左子树任意一个节点小于K,右子树任意一个节点大于K;
 中游周游后由小到大
 插入，搜索，删除操作时间复杂度都为O(h),h为高度；
 删除规则：若删除节点没有左节点，将右节点的根代替该节点；有左子树，将左子树的最大值（中跟周游最后值）去掉代替，再用其左子树代替该最大值 
 */ 
 
 /*哈夫曼树
 信息压缩编码，频率高的编码短，且任意字符的编码不能称为别的字符的编码前缀
 已知不同字符的权重，权重越高频率越大；
 建树，选最小的两个合并为一个子树，树根为两权重的和，树根代替两树叶，重复，直到树建成；
 编码就选从根到节点的路径，左为1，右记0，绝对没有二义性问题。 
 即所有字符都是外部节点，且满足带权外部路径长度最小 
 构造结构体{left,right,num,parent} 
 适用于频率不等，差别较大的情况 
 */ 
 
 
 ///////////////////哈夫曼算法///////////////////////// 
#include<stdio.h>
#include<stdlib.h>
struct Leaf{
	int num;//权重
	int parent;
	int left,right; 
};  
struct Tree{
	struct Leaf leaf[150];//最大结点数应该2*m(数据数)-1
	int root;//树根位置； 
};
typedef struct Tree * tree;

void findmin(tree tr,int pos,int *x1,int*x2){//寻找最小的两个值 
	int min1=1e5,min2=1e5;//最小的真实值
	int i;
	for(i=0;i<pos;i++){
		if(tr->leaf[i].num<min1&&tr->leaf[i].parent==-1){
			min2=min1;
			min1=tr->leaf[i].num;
			*x2=*x1;
			*x1=i;
		}
		else if(tr->leaf[i].num<min2&&tr->leaf[i].parent==-1){
			*x2=i;
			min2=tr->leaf[i].num;
		}
	}
}

tree creat(int m,int *w){//w是w[0]的地址，m是字符数 
	tree tr;
	int i,j;
	int x1,x2;//两个最小数
	tr=(tree)malloc(sizeof(struct Tree));
	if(tr==NULL){
		printf("created failed");
		return tr;
	} 
	for(i=0;i<2*m;i++){//建初始的树，先存数据 
		tr->leaf[i].left=-1;
		tr->leaf[i].right=-1;
		tr->leaf[i].parent=-1;
		if(i<m) tr->leaf[i].num=w[i];
		else tr->leaf[i].num=-1;
	}
	for(i=0;i<m-1;i++){//构造树，建立联系 
		x1=x2=-1;
		findmin(tr,m+i,&x1,&x2);//找到最小的两个值,建造小数，新根存在m+i 
		tr->leaf[x1].parent=m+i; 
	    tr->leaf[x2].parent=m+i;
	    tr->leaf[m+i].num=tr->leaf[x1].num+tr->leaf[x2].num;
	    tr->leaf[m+i].right=x2;//让左边代表最小，记为1 
	    tr->leaf[m+i].left=x1;
	    tr->root=m+i; 
	} 
	return tr;
} 

void read(tree tr,int root){//中根周游 
	if(tr->leaf[root].left!=-1)
	read(tr,tr->leaf[root].left);
	printf("%d ",tr->leaf[root].num);if(tr->leaf[root].right!=-1)
	read(tr,tr->leaf[root].right);
}
int main(){
	int a[20]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
	tree tr=creat(20,a);
    read(tr,tr->root);
}



/*描述
   二叉搜索树在动态查表中有特别的用处，一个无序序列可以通过构造一棵二叉搜索树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插
   入的新的结点都是二叉搜索树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。

   这里，我们想探究二叉树的建立和序列输出。

输入
只有一行，包含若干个数字，中间用空格隔开。（数字可能会有重复）
输出
输出一行，对输入数字建立二叉搜索树后进行前序周游的结果。
样例输入
41 467 334 500 169 724 478 358 962 464 705 145 281 827 961 491 995 942 827 436 
样例输出
41 467 334 169 145 281 358 464 436 500 478 491 724 705 962 827 961 942 995 */
#include<stdio.h>
#include<stdlib.h>
struct Leaf{
	int num;
	int left;
	int right;
};
struct Tree{
	struct Leaf *leaf;
	int root;
};
typedef struct Tree* tree;

void getin(tree tr,int n,int ni){
	if(tr->root==-1) {tr->root=0;tr->leaf[0].num=n;return;
	}tr->leaf[ni].num=n;
	int i=tr->root,j,flag;
	while(tr->leaf[i].num!=n&&i!=-1){j=i;
		if(tr->leaf[i].num>n) i=tr->leaf[i].left;if(i!=-1)j=i;
		if(tr->leaf[i].num<n&&i!=-1) i=tr->leaf[i].right;
	
	}
	if(i!=-1) ;
	else if(tr->leaf[j].num>n) { tr->leaf[j].left=ni;
	}
	else if(tr->leaf[j].num<n) tr->leaf[j].right=ni;
}

tree  creat(){
	tree tr;
	tr=(tree)malloc(sizeof(struct Tree));
	tr->leaf=(struct Leaf*)malloc(sizeof(struct Leaf)*1000);
	tr->root=-1;
	int i;
	for(i=0;i<1000;i++){
		tr->leaf[i].num=-1;
		tr->leaf[i].left=-1;
		tr->leaf[i].right=-1;
	}
	return tr;
}

void print(tree tr,int root){
    if(root<10000)	printf("%d ",tr->leaf[root].num);
	if(tr->leaf[root].left!=-1) print(tr,tr->leaf[root].left);
	if(tr->leaf[root].right!=-1) print(tr,tr->leaf[root].right);
}

int main(){
	int a;
	char k=' ';
	int num=0,i=0,n=0;
	tree tr=creat();	scanf("%d",&a);getin(tr,a,i);i++;
	for(;k==' ';){
	
			scanf("%d",&a);getin(tr,a,i);i++;k=getchar();
}


	print(tr,tr->root);
}





//树的定义与运用与二叉树类似，只是儿子的数量不限；
//常见表示法，1、父节点表示，方便找父节点，但找兄弟不方便，可以在数组中顺序存储 ，先根序；
//2、子表表示，struct leaf{int a;struct leaf*link;}link接着一个链表，顺序存放子节点 ；
//3、长子父亲表示法：最常用，存储长子和父亲 
//树可以先根/后根/中根/广度优先周游；
//广度优先：队列，根入队列，若队列非空{获取删除节点；访问长子，长子入队->右兄弟入队} 

//若干棵树组成森林，森林可以先根与后根周游
//树/树林->二叉树：1、每个相邻兄弟节点连线；2、每个父节点只保留最左子节点的连线；（树林则在造节点连接各根作为“虚拟根”） 
//左节点是原子女；右节点是兄弟，根节点总没有右子女； 
//二叉树->树/树林 ：B是二叉树，F(B)（代表树林）是T1(根为r，r是B的根)加上树林F(右子树)， 
//如果若某结点是其父母的左子女，则把该结点的右子女，右子女的右子女……，
//都与该结点的父母连起来，最后去掉所有的父母到右子女的连线 




/*前序/后序 +中序可以还原二叉树；*/
//思路：不断找根，建立连接重建树 



/*描述
给定一棵二叉树的前序遍历和中序遍历的结果，求其后序遍历。

输入
输入可能有多组，以EOF结束。
每组输入包含两个字符串，分别为树的前序遍历和中序遍历。每个字符串中只包含大写字母且互不重复。
输出
对于每组输入，用一行来输出它后序遍历结果。
样例输入
DBACEGF ABCDEFG
BCAD CBAD
样例输出
ACBFGED
CDAB
提示
以英文题面为准*/
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
struct Leaf{
	char ch;
	int right;
	int left;
}; 
struct Tree{
	struct Leaf *leaf;
	int root;
};
typedef struct Tree* tree;

tree creat(){
	tree tr;
	tr=(tree)malloc(sizeof(struct Tree));
	tr->root=-1;
	tr->leaf=(struct Leaf*)malloc(sizeof(struct Leaf)*1000);
	for(int i=0;i<1000;i++){
		tr->leaf[i].left=-1;
		tr->leaf[i].right=-1;
		
	}
	return tr;
} 
int change(tree tr,char*b,int bstart,int bend,int astart,int aend){
	if(bstart>bend||astart>aend) return -1;
	char ch;
	ch=b[bstart];
	int i=astart;
	while(tr->leaf[i].ch!=ch){
		i++;
	}
	if(tr->root==-1)tr->root=i;
	tr->leaf[i].left=change(tr,b,bstart+1,i-astart+bstart,astart,i-1);
	tr->leaf[i].right=change(tr,b,i-astart+bstart+1,bend,i+1,aend); 
	return i;
}

void print(tree tr,int root){
	if(tr->leaf[root].left!=-1)print(tr,tr->leaf[root].left);
	if(tr->leaf[root].right!=-1)print(tr,tr->leaf[root].right);
	printf("%c",tr->leaf[root].ch);
}
int main(){
	char a[1000],b[1000];
	int j=0;//标志，输出换行； 
    while(scanf("%s",b)!=EOF){//文件以EOF作为结束标志；字符串用scanf可以避免空格 
	if(j!=0)printf("\n");
       scanf("%s",a);
    	int i=0;
    	tree tr=creat();
	while(a[i]!='\0'){
			tr->leaf[i].ch=a[i++];
		}	

    	change(tr,b,0,strlen(b)-1,0,strlen(b)-1);
    	print(tr,tr->root);
    	i=0;j++;
    }
}
