/*
图：多对多，网状关系；节点加关系（边）
分类：无向图：每条边没有方向 （a,b）
有向图：每条边有方向<a,b>,a是始点，b是终点 

概念：设(a,a)不算边 
1、完全图：每一个顶点都与其它所有节点连接 
  有向/无向完全图：顶点数n，边数e，
    有向完全图e=n(n-1) ，无向e=n(n-1)/2;
	n相同，完全图e最大；
2、顶点的度：D(v),与顶点相关联的边数；
   若为有向图，D(v)=ID(v)+OD(v),ID表示入度，以v为终点，OD为出度，以v为起点	 
   e=ΣD(vi) /2;
3、子图：图G,一些G中的节点与边组成的图即G的子图；
4、路径：a与b存在一条路径：存在x1,x2...xn,存在(a,x1)(x1,x2)...(xn,b)
 路径长度：边数；
 简单路径：a,b可以相同，x1,x2...xn都不同； 
 回路/环：a=b的简单路径 ；
5、根：存在顶点v，v与其它的节点都有路径，v称为图的根，图为有根图；
   完全图一定是有根图，每个节点都是根；
6、连通：a,b有路径->ab连通 
    连通图：任意两个节点都连通（只包括一个顶点的图也是） 
	无向：  连通分量：无向图的最大连通子图，
	             连通图的连通分量是自己；
				  非连通的无向图一定有多个连通分量
	有向：强连通图：任意a,b都强连通，有a->b,b->a的路径
	      强连通分量：有向图的最大强连通子图	
		       强连通图的强连通分量是自己；
				  非连通的有向图一定有多个强连通分量		   
7、带权图：每个边上附带一个权值
    网络：带权的连通图


图的存储
1、邻接矩阵表示	
矩阵A,aij=1((vi,vj)/<vi,vj>是边)；0/∞（不是边）；
      或者是边则aij=权值，不是，为0/∞  
	  aii记为0；
	  无向图D(vi) =第i行/列的非零元素；
	  有向图：ID(vi)第i列非零元素；OD(vi)第i行非零元素；
空间O(n^2)	
2、邻接表表示法：
顺序存储的顶点表+n个链式存储的边表 ；
有向图要两组边表
 顶点表存储所有顶点地信息，边表表示与对应节点关联的边；
 O(n+e)/O(n+2e);
 若e=O(n^2),邻接矩阵/若e小，邻接表
 v1->{v1,v2,(v1,v3)} ->
3、邻接多重表：
将同一个边的边表节点合成为1个；
无向图：v1/v2->{v1,v2,(v1,v3),(v2,v3)}分别表示与v1/v2关联的下一个边；
有向图：两组表；
   
图的基本运算与周游  
  图的周游/遍历： 需要标记是否访问过 
  深度优先： v->w1->...(与上一个节点关联)知道访问到未连访问过的节点；
                w2-> ...
              ...
            如果还有未被访问过的节点，从另一个未访问的节点继续；
 广度优先：v->w1->w2...wn;
            对w1/w2...进行广度访问 
            如果还有未被访问过的节点，从另一个未访问的节点继续；
            
图的最小生成树
 1、 对于连通的无向图/强连通的有向图，从任一顶点出发，周游，可以访问到所有节点
      若对有顶点的有向图，从顶点出发；
2、周游时经过的顶点和边组成了图的一个连通子图，称为图的一个生成树；
连通图的生成树是一个极小连通子图；
 3、在一棵生成树中，增加一条边，必定构成环；减少一条边，必定不再连通；
 顶点数为n,无向图边数小于n-1必定不连通；
          大于n-1必定存在环；
         等于n-1不一定是生成树
 4、DFS生成树：深度周游形成；
 BFS生成树：广度生成树；
 对非连通的无向图或非强连通的有向图，只能生成树林；
 5、对于网络，权值最小的生成树称为最小生成树；
  性质：网络G,U是G顶点的一个真子集，
     存在多个节点(ui,vi),ui∈U,vi∈G-V;
	 若（u,v）是权值最小的一条边，则一定存在G的一颗最小生成树包括此边；
构造：Prim算法；Kruskal算法；


最短路径
1、两顶点间的最短路径即路径长度最短的路径；
  若是带权图，长度按权值计算；
2、从一个顶点到其它所有节点的最短路径
  Floyd算法/Dijkstra方法
  
拓扑排序
1、AOV网：顶点活动图，顶点表示活动，有向边表示先后关系
（比如课程与先导课）
2、对一个AOV网，若所有节点构成一个序列{v1,v2...vn}
  满足：若vi->vj存在，则vi在vj前；
   则这种排序成为拓扑序列，操作成为拓扑排序；


关键路径
AOE网：带权有向图，边活动网
  顶点表示事件，边代表活动，权值代表活动开销
完成整个工程的最短时间是从开始顶点->结束顶点的最长路径长度
比如1->2,一条路径长10，另一条长5，事实上两条路径的事件都要做（可以同时做）所以事件为10 
   称为关键路径     	           
*/ 
#include<stdio.h>
#include<stdlib.h>
#include<string.h> 
/////////////////图的存储////////////////////////// 
struct pic{//邻接矩阵 
	int *node;//存储节点的链表，此处设立节点是整数
	int matrix[10][10];//邻接链表 
	int n; //表示节点个数 
};
typedef struct pic pic;

pic* creat(){//创建邻接矩阵表示的图 O(n^2)
	pic* p;
	p=(pic*)malloc(sizeof(pic));
	p->node=(int*)malloc(sizeof(int)*10);
	p->node[0]=5;p->node[1]=4;p->node[2]=2;p->node[3]=6;p->node[4]=3;
	int i,j;
	for(i=0;i<10;i++){
		for(j=0;j<10;j++){
			p->matrix[i][j]=0;
		}
	}
	p->matrix[0][1]=p->matrix[1][0]=1;
	p->matrix[1][2]=p->matrix[2][1]=2;
	p->matrix[2][3]=p->matrix[3][2]=3;
	p->matrix[1][3]=p->matrix[3][1]=1;
	p->matrix[0][4]=p->matrix[4][0]=2;
	p->n=5;
	return p; 
}

struct  side{//边 
	struct side *next;//链接下一个边 
	int start;//边的起终点 ，start表示开头顶点表的节点 
	int end; 
	int weigh;//权值 
};
struct Node{//顶点 
	struct side *side;//边表的起点
	int nodenum;//顶点信息 
}; 
struct pic1{//邻接表 
	struct Node *node;
	int n;//顶点个数； 
};
typedef struct pic1 pic1;
pic1* creat1(){//创建邻接表的图 O(n+e/2e) 
	pic1* p;
	p=(pic1*)malloc(sizeof(pic1));
	p->node=(struct Node*)malloc(sizeof(struct Node)*5);
	p->n=5;
	p->node[0].nodenum=5;p->node[1].nodenum=4;p->node[2].nodenum=2;p->node[3].nodenum=6;p->node[4].nodenum=3;
	p->node[0].side=(struct side*)malloc(sizeof(struct side));
	p->node[0].side->weigh=1;p->node[0].side->start=0;p->node[0].side->end=1;
	p->node[0].side->next=(struct side*)malloc(sizeof(struct side)); 
	struct side*q=p->node[0].side->next;
	q->start=0;q->end=4;q->weigh=2;q->next=NULL;
	q=p->node[1].side=(struct side*)malloc(sizeof(struct side));
	q->start=1;q->end=0;q->weigh=1;q->next=(struct side*)malloc(sizeof(struct side));
	q=q->next;q->start=1;q->end=2;q->weigh=2;q->next=(struct side*)malloc(sizeof(struct side));
	q=q->next;q->start=1;q->end=3;q->weigh=1;q->next=NULL;
	q=p->node[2].side=(struct side*)malloc(sizeof(struct side));
	q->start=2;q->end=1;q->weigh=2;q->next=(struct side*)malloc(sizeof(struct side));
	q=q->next;q->start=2;q->end=3;q->weigh=3;q->next=NULL;
	q=p->node[3].side=(struct side*)malloc(sizeof(struct side));
	q->start=3;q->end=1;q->weigh=1;q->next=(struct side*)malloc(sizeof(struct side));
	q=q->next;q->start=3;q->end=2;q->weigh=3;q->next=NULL;
	q=p->node[4].side=(struct side*)malloc(sizeof(struct side));
	q->start=4;q->end=0;q->weigh=2;q->next=NULL;
	return p;
}




///////////////////////////周游算法//////////////////////////////////////////
//深度周游（递归） dfs
void dfsvisit(pic*p,int*flag,int i){
	printf("%d ",p->node[i]);
	flag[i]=1;
	int m=0;
    for(;m<p->n;m++){//对矩阵来说的遍历vi的所有相邻节点 
    	if(p->matrix[i][m]!=0&&flag[m]==0){
    		dfsvisit(p,flag,m);
    	}
    }
}

void dfs(pic*p){//深度周游，邻接矩阵 
	int flag[p->n];
	int i;
	for(i=0;i<p->n;i++){
		flag[i]=0;
	}
	for(i=0;i<p->n;i++){
		if(flag[i]==0){
			dfsvisit(p,flag,i);
		}
	}
} 

void dfsvisit1(pic1*p,int*flag,int i){//对vi进行深度周游 ,邻接表 
	printf("%d ",p->node[i].nodenum);//print vi;
	flag[i]=1;//标记 
	struct side*q;
	q=p->node[i].side;//第一个节点 
	while(q!=NULL){
		if(flag[q->end]==0){
			dfsvisit1(p,flag,q->end);//对新节点进行深度遍历 
		}
		q=q->next;//先将vi的邻居全部深度遍历 
	}
	 
} 
void dfs1(pic1 *p){//深度周游 
	int flag[p->n];//标记是否浏览过
	int i;
	for(i=0;i<p->n;i++){
		flag[i]=0;
	} 
	for(i=0;i<p->n;i++){
		if(flag[i]==0){//循环次数=连通分量个数 
			dfsvisit1(p,flag,i);//对vi进行深度周游 
		}
	}	 
} 
//时间复杂度邻接矩阵O(n^2),邻接表O(n+e);
//空间复杂度O(n) 
 
//广度周游 (队列)cfs
//对所有未读元素循环（print->入队->循环，直到队空（队首出队->邻接所有未读的print->入队））
struct list{//队列 
	int *nodenum;
	int p,q;
	int n; 
}; 
typedef struct list list;
list* creatlist(){//创建队列 
	list* p;
	p=(list*)malloc(sizeof(list));
	p->nodenum=(int*)malloc(sizeof(int)*100);
	p->p=p->q=-1;
	p->n=100; 
}
void pop(list*p,int i){//入队 
	p->p=(p->p+1)%p->n;
	p->nodenum[p->p]=i;
}
int golist(list*p){//读取并出队 ,返回节点信息 
    int node;
    node=p->nodenum[(p->q+1)%p->n];
	p->q=(p->q+1)%p->n;
	return node; 	
}
int judge(list *p){//判断是否空队
    if(p->q==p->p) return 1;
    else return 0;	
}
void cfsvisit(pic1*p,int*flag,int i){
	list *lp;
	lp=creatlist();
	struct side*q;
	int j;
	printf("%d ",p->node[i].nodenum);
	flag[i]=1;
	pop(lp,i);
	while(judge(lp)==0){
		j=golist(lp);
		q=p->node[j].side;//第一个节点 
	    while(q!=NULL){
		if(flag[q->end]==0){
			printf("%d ",p->node[q->end].nodenum); 
			flag[q->end]=1;
			pop(lp,q->end);
		}
		q=q->next;//先将vi的邻居全部深度遍历 
	}
	}
}
void cfs(pic1*p){
	int flag[p->n];
	int i;
	for(i=0;i<p->n;i++){
		flag[i]=0;
	}
	for(i=0;i<p->n;i++){
		if(flag[i]==0){
			cfsvisit(p,flag,i);
		}
	}
}  
//时间复杂性O(n^2)/O(n+e);空间复杂度不超过O(n)；


///////////////////对网络（带权连通图）求最小生成树(不一定唯一)/////////////////////////////////////	 
//prim算法：记录n-1条边来记录树；
//1、集合U为最小生成树；2、v0进入U,记录n-1条边(v0,v1)...(v0,vn-1)，记录权值，若不相邻记为∞ 
//3、选权值最小的一条边记录(v0,vx)，与(v0,v1)调换位置 
//4、调整剩下的n-2条边 ，若(v0,vi) >(vx,vi),替换；
//5、循环
struct Mst{//记录边 
	int start,end;
	int weigh;
};  
typedef struct Mst Mst;
int bijiao(int a,int b){//若a小于b返回1,权值0记为∞ 
	if(a<b&&a!=0) return 1;
	else if(a>0&&b==0)return 1;
	return 0; 
}
void prim(pic*p,Mst* mst){ 
	Mst edge;
	int i=0;
	for(i=0;i<p->n-1;i++){//2
		mst[i].start=0;
		mst[i].end=i+1;
		mst[i].weigh=p->matrix[0][i+1];
	} 
    for(i=0;i<p->n-1;i++){
    	int min=100,mini=0,minj=0;
	    for(int j=i;j<p->n-1;j++){//3
	      	if(bijiao(mst[j].weigh,min)){
		    	mini=mst[j].end;
		     	min=mst[j].weigh;
		     	minj=j;
	        }
       	} 
       	edge=mst[minj];mst[minj]=mst[i];mst[i]=edge;//mst[min]与mst[i]交换 
		for(int j=i+1;j<p->n-1;j++){
			if(bijiao(p->matrix[mini][mst[j].end],mst[j].weigh)){
				mst[j].start=mini;
				mst[j].weigh=p->matrix[mini][mst[j].end];
			}
		}   	
    }
} 
//时间复杂度O(n^2)

// Kruskal算法：集合T(V,D)，V是所有节点，D是边，一开始是空的 
/*while(D数量<n-1){
    E中当前最短边(u,v);
	E删去(u,v);
	if((u,v)假如T不产生回路){
	    （u，v）放入T; 
	} 
}*/


/////////////////////////最短路径/////////////////////////////////////
//Dijkstra算法：同时求出 某顶点到其它所有顶点的最短距离
//dist是最短路径的集合，记录最短路径长度 
//U是子图，只包括最短路径的顶点 ,记录每一个节点的路径长度，
//U节点的路径长度即最短路径长度；非U的路径长度为U中结点为中间节点（可能不是）的最小路径长度 
/*1、开始， U只有v0, v0路径长度记为0； 其它节点记为边的权值，不相邻记为∞
2、选取不属于U的vmin进入U
3、调整其它节点路径，比较(v0,vmin)+(vmin,vj)与(v0,vj)选小的 
4、 重复23
*/
typedef struct{
//	int node;//节点信息 
	int len;//路径长度
	int befo;//vi前一个节点 ,-1表示不相邻 
}Path;

void dijkstra(pic *p,Path*dist){
	dist[0].befo=0;
	dist[0].len=0;
	p->matrix[0][0]=1;//标记，表示v0进入U
	int i;
	for(i=1;i<p->n;i++){//初始化 
		dist[i].len=p->matrix[0][i];
		 if(dist[i].len==0) dist[i].befo=-1;
		 else dist[i].befo=0; 
	} 
	for(i=1;i<p->n;i++){
		int min=100,minj=0;
		for(int j=1;j<p->n;j++){//找最小 
			if(bijiao(dist[j].len,min)&&p->matrix[j][j]==0){
				min=dist[j].len;
				minj=j;
			}
		}
		if(minj==0) break;//没有相邻， 
		p->matrix[minj][minj]=1;//标记，加入U 
		for(int j=1;j<p->n;j++){// 调整 (加入U不是按顺序)
			if(p->matrix[j][j]==1)continue;//加入U了
			if(bijiao(min+p->matrix[minj][j],dist[j].len)){//改变dist 
			if(min){
				if(p->matrix[minj][j]!=0){
				dist[j].befo=minj;
				dist[j].len=min+p->matrix[minj][j]; 					
				}
			}
			} 
		}
		   for(int k=0;k<p->n;k++){
    	printf("(%d,%d)",dist[k].len,dist[k].befo);
    }printf("\n"); 
	}
} 
//时间复杂度O(n^2)


//Floyd算法 ：邻接矩阵，时间复杂性O(n^3) 
//求出两个节点的最短路径
//记录最短路径长度以及路径，定义两个矩阵A[][],nextvex[][];
//初始A为matrix；nextvex只记录直接相连的 
//A[i][j]记录当前情况下的vivj最短路径，nextvex[i][j]记录当前最短路径的vi的直接后继,不存在路径则为-1；
//1、比较(vi,vj)与(vi,v0)+(v0,vj);选更小的为当前最短路径；
//2、循环，用vk..直到vn-1
typedef struct{
	int A[100][100];
	int nextvex[100][100];
}shortpath; 
void floyd(pic *p,shortpath *ppath){
	int i,j,k;
	for(i=0;i<p->n;i++){//初始化 
		for(j=0;j<p->n;j++){
			if(p->matrix[i][j]!=0) ppath->nextvex[i][j]=j; 
			else ppath->nextvex[i][j]=-1;
			ppath->A[i][j]=p->matrix[i][j]; 
		}
	}
	for(k=0;k<p->n;k++){
		for(i=0;i<p->n;i++){
			for(j=0;j<p->n;j++){
				if(ppath->A[i][k]==0||ppath->A[k][j]==0)continue;//若不存在(vi,vk,vj),不考虑
				if(bijiao(ppath->A[i][k]+ppath->A[k][j],ppath->A[i][j])){
					ppath->A[i][j]=ppath->A[j][i]=ppath->A[i][k]+ppath->A[k][j];//无向图
					ppath->nextvex[i][j]=ppath->nextvex[i][k]; 
				} 
			}
		}
	}
}



/////////////////////////拓扑排序//////////////////////////////////////////
/*拓扑排序前，先调用findInDegree得到所有结点的入度，
然后将所有入度为0的顶点压栈。
C从栈顶取出一个顶点V，由它的出边表可以得到以该顶点
为起点的出边，将这些边终点的入度减1，即”删除”这
些边。
C如果某条边终点的入度为0，则将该顶点入栈。
C反复进行上述操作，直到栈为空
*/ 
void findindegree(pic1*p,int*indegree){//邻接出边表 //统计所有点入度 
	int i;
	for(i=0;i<p->n;i++){
		indegree[i]=0;
	}
	struct side*  q;
	for(i=0;i<p->n;i++){
		q=p->node[i].side;
		while(q){//直到为空 
			++indegree[q->end];
			q=q->next;
		} 
	}
} 

int toposort(pic1*p,int *ptopo){//拓扑排序 
	struct side* q;
	int *indegree=(int *)malloc(sizeof(int)*p->n);
	findindegree(p,indegree);//统计入度，置初值
	int i;
	int top=-1;
	for(i=0;i<p->n;i++){
		if(indegree[i]==0){//入度为0，入栈 
			indegree[i]=top;//记录栈的上一个元素，已经入度为0，所以利用indegree 
			top=i;
		}
	} 
	int j,nodeno=0,k;
	while(top!=-1){//栈不为空 
		j=top;//当前栈顶元素
		top=indegree[top];//退栈(上一个入度为0的元素)
		ptopo[nodeno++]=j;//输出到拓扑序列
		q=p->node[j].side;//边表第一个边界点；
		while(q){
		    k=q->end;
			indegree[k]--;//入度-1
			if(indegree[k]==0){
				indegree[k]=top;
				top=k;//新的入度为0的边入栈 
			}	
			q=q->next; 
		} 
	}
	free(indegree);
	if(nodeno<p->n){//存在回路 
		printf("存在回路");
		return 0; 
	} 
	return 1;
}


int main(){
//	pic1*p;
//	p=creat1();
//	cfs(p);

    pic1*p;
    p=creat1();
//    Mst mst[p->n-1];//若在函数内设mst[],传输地址，会造成信息丢失 
//	prim(p,mst);
//    int i=0;
//    for(i=0;i<p->n-1;i++){
//    	printf("(%d,%d,%d)",mst[i].start,mst[i].end,mst[i].weigh);
//    }

//    Path dist[p->n];
//    dijkstra(p,dist);
//    int i=0;
//    for(;i<p->n;i++){
//    	printf("(%d,%d)",dist[i].len,dist[i].befo);
//    }

//    shortpath ppath;
//    floyd(p,&ppath);
//    int i=3,j=4;
//    printf("%d\n",ppath.A[i][j]);
//    while(i!=j){
//    	printf("(%d,%d)",i,ppath.nextvex[i][j]);
//    	i=ppath.nextvex[i][j];
//    }
    int *ptopo;
	ptopo=(int*)malloc(sizeof(int)*p->n);
	if(toposort(p,ptopo)){
		int i=0;
		for(i=0;i<p->n;i++){
			printf("%d ",ptopo[i]);
		}
	}
 
    
} 
