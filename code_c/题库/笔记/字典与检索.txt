/*字典与检索
字典：关键码+属性；静态/动态字典；
检索：给定key，查找元素，否则返回失败；精确查找/范围查找；

检索算法： 
衡量算法的效率一般用ASL=Σ(1~n)pici,n为元素总数；p为搜索概率，一般为1/n,c为比较次数 
////////////////////////已排序顺序表/////////////////////////////// 
已排序顺序表：1、顺序检索，从头开始；ASL=(1+2+...n)/n=O(n);
改进：使用堆来组织字典，不等概率下，概率（搜索成功次数最大）较大的排在前面；建堆，ki<k2i+1/k2i+2 
2、二分检索： 要求已经排好序，while(front<rear)mid=(front+rear)/2,front=mid+1;rear=mid;
检索过程可以用二叉树来描述--判定树：比较次数最多为log2n;
ASL≈log2(n+1)-1;
3、分块检索：前一块最大关键码必须小于后一块最小关键码，每一块中的关键码不一定有序 ；
kuai{yuansu1,yuansu2...}  biao{kuai1,kuai2...}两步检索；
ASL:log2(1+n / s ) + s,n个数据 ，s块；若块和块内部都顺序检索，取s=n**0.5,ASLmin=n**0.5;

/////////////////////////散列存储/////////////////////////////////////////// 
散列存储，散列函数：定义一个函数h(x),每一个元素的地址为h(keyi);散列表：用散列法表示的字典；
碰撞/同义词：h(key1)=h(key2)称为碰撞,key1与key2称为同义词；
基本区域：h(x)的值域对应空间；
溢出区：基本区域以外，同义词可以存放于溢出区或基本区域未被占用的单元；
负载因子(α) = 散列表中结点数目/ 基本区域能容纳的结点数
1、选择散列函数：元素在基本区域的任意地址的概率均等（减少碰撞）；函数尽可能简单减少碰撞；
（1）直接定址法：取关键字或关键字的某个线性函数，h(key) = a*key+b（a和b为常数） ，适用于关键码连续，减少空单元造成浪费；
（2）数字分析法：关键码数位比存储区的地址码位数多，这时可以对各位进行分析，丢掉分布不均匀的位而留下均匀的位作为地址，
例：(395003, 395010, 395012, 395085, 395097)，
C 前四位相同，后两位随机分布，故可以取后两位构成散列函数，
得到的散列地址为（03，10，12，85，97） 适于静态字典；
（3）平方取中法：比如key = 4731，key2 = 22382361，如地址码为3位，则可以取382为散列地址，即h(4731) = 382 ；
（4）折叠法：比如key = 0582422241，地址位数为4。
2241+ 8242+05=[1] 0488=0488
(5)除留余数法，h(key)=n%p,注意p一般选择max{最大质数p|p<m},m为散列表长度 ；
（6）基数转换法，将key看作不同进制下的数，计算，取数位，
如key=236075；[236075]13=5+7*13+6*13^3+3+13*4+2*13^5=841547,取2~5位，h(key)=4154;
注意两个进制需要互素(10,13);
 2、处理碰撞
 （1）开地址法：当碰撞发生时，用某种方法在基本区域内形成一个探查序列，沿着探查序列逐个单元查找，直到找到该元素或碰到
一个未被占用的地址为止；若插入元素，则碰到空的地址单元就存放要插入的同义词。若检索元素，则碰到空的地址单元说明表中没有待查的元素；
形成探查序列：1、线性探查法：若d发生碰撞，则依次探查d+1,d+2...m-1,0,1...d-1;若存在空的，存在第一个空地址；若不存在溢出；
            检索时可以从d依次向后试探；
			线性探查容易出现二次堆积，即不同key的元素也发生碰撞；比如由于同义m已被存进d+1,但又有一个d+1的元素；
			2、 双散列函数法：使用两个函数，h2取值为0~m-1且与m互素；
			若h1被占用，用h2,若还是不行，用(h1+h2)%m,(h1+2h2)%m... ->找到/溢出；
开地址法不能轻易删除节点，只能标记1/0，造成空间浪费；
（2）拉链法：采用链表，每个地址后根所有的同义词链表；
较快/易删除/无堆积/；
有时把一个地址下一组同义词称为一个“桶”；


散列函数与ASL：1散列函数的“好坏”首先影响出现冲突的频率。
C 对于同一组随机的关键码，“均匀分布”的散列函数产生碰撞
的可能性相同，则可不考虑它对ASL的影响。
2、处理碰撞的方法
C 通常拉链法的ASL要小于开放地址法。线性探测容易产生“二
次聚集[堆积]”问题，而拉链法不会出现这种情况。
3、装填因子
C 装填因子越小，发生碰撞的可能性越小；反之，装填因子越大，
表中已填入的记录多，再填记录时，发生碰撞的可能性就越大，
检索时比较次数就越多			 
 
 
 
 ///////////////索引搜索/////////////////////////////////////
索引搜索：建立索引，运用索引表实现地址到key的映射；
索引实际上也是字典，关键码+地址；  密集/稀疏索引：一个索引项对应1个/几个元素；稀疏索引可以用来分块索引，比如只记录最大key；
 以关键码作索引--二叉树；
 二叉排序树；删除，1、若p没有左节点，将右子女代替；若有，right树中跟周游最min节点r删去并p=r;
                  2、 若p没有左节点，将右子女代替；若有， 左树中跟周游最后节点r删去并p=r;
		为保证二叉树的性能稳定，构造平衡二叉排序树；
		AVL树的定义：  每个结点左、右子树深度之差的绝对值不超过1；
C                  结点左、右子树深度之差定义为该结点的平衡因子，则树中每个结点的平衡因子只能是1、0或-1 
       具有N个结点的AVL树的高度不会超过1.44log N，且通常接近log N ；
       AVL树的平衡调整：
	   1、找到最小不平衡子树
	   2、LL,在左子女的左子树插入节点，(αBβ) A (γ)= (α) B (βAγ)；
	    RR,(α) A (βBγ)= (αAβ) B (γ);
		LR:((α)B(βCγ))A(δ)= (αBβ)C(γAδ);
		RL:(α)A((βCγ)B(δ))= (αAβ)C(γBδ) 
	    
 
*/ 
