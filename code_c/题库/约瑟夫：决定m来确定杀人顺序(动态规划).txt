/*M4：约瑟夫
描述
约瑟夫的问题是众所周知的。对于那些不熟悉原始问题的人：从n个人中，编号为1，2，...，n，每一个mth都将被处决，
只有最后剩下的人的生命将被挽救。约瑟夫很聪明，能够选择最后剩下的人的位置，从而挽救了他的生命，给我们传达了有关这一事件的信息。
例如，当 n = 6 和 m = 5 时，将按顺序 5、4、6、2、3 和 1 执行人员。
假设有k好人和k
坏人。在圈子里，前k个是好人，最后k个是坏人。你必须确定这么小的m，所有的坏人将被执行之前，第一个好人。

输入
输入文件由包含 k 的单独行组成。输入文件中的最后一行包含 0。你可以假设0<k < 14。
输出
输出文件将由单独的行组成，这些行包含与输入文件中 k 对应的 m。
样例输入
3
4
0
样例输出
5
30*/
#include<stdio.h>
#include <stdio.h>

int main()
{
    int people[50] = {0}, k, Joseph[14] = {0};//Joseph用于打表，不然超时
    while(scanf("%d", &k) != EOF && k != 0)
    {
        if (Joseph[k] != 0)
        {
            printf("%d\n", Joseph[k]);
            continue;
        }
        int n = 2 * k;
        int m = 1;
        people[0] = 0;//people[0] = 0表示编号从0开始
        for (int i = 1; i <= k; i++)
        {
            //每次枚举完毕将剩下的人按从0到n - i编号，只要好人没有杀掉，则前面k - 1个编号是不变的
            people[i] = (people[i - 1] + m - 1) % (n - i + 1);
            if (people[i] < k)//第k个人的编号为k - 1,所以这里是<而不是<=
            {
                i = 0 ;
                m++;
            }
        }
        Joseph[k] = m;
        printf("%d\n", m);
    }
    return 0;
}
