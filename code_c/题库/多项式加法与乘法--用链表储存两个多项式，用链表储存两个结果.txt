//多项式的加法与乘法并显示 
//输入：两行，每行表示一个多项式，按多项式的指数降序输入，一个多项式的输入用0 0表示结束
//输出： 两行， 第一行为多项式的加，第二行为多项的乘 
#include<stdio.h>
#include<stdlib.h>
struct Node{ 
    int exp;  //指数
    int coef; //系数
    struct Node *next;
};
typedef struct Node* Poly;//结构体指针类型 
void print(int a,int b){//将不同的系数与指数情况进行输出 

	    if(b==0){
    	printf("%d",a);
    }
    else if(b==1){
        if(a==1){
    	printf("x");
    }
    else if(a==-1){
    	printf("-x");
    }
    else{
    	printf("%dx",a);
    }
    }
    else if(a==1){
    	printf("x^%d",b);
    }
    else if(a==-1){
    	printf("-x^%d",b);
    }
    else{
    	printf("%dx^%d",a,b);
    }
}
void printPolynomial(Poly A){//显示结果函数 
    int a,b;
    a=A->coef;
    b=A->exp;
    print(a,b);//第一项不需要‘+-’ 
    A=A->next;
	while(A!=NULL){
		a=A->coef;
        b=A->exp;
        if(a>0){//系数小于0，数字自带‘-’ 
        	printf("+");
        }
        print(a,b);
        A=A->next;
    }
}
Poly creat(int n){//根据节点数（次数）创建新顺序表 
	Poly head;
	Poly node,old;
	int i=n;
	node=head=(Poly)malloc(sizeof(struct Node));
	for(;i>=0;i--){
		old=node;
		node->exp=i;
		node->coef=0;
		node->next=(Poly)malloc(sizeof(struct Node));
		node=node->next;
	}free (node);
	old->next=NULL;
	return head;
}

void deleted(Poly head){//删除系数为0节点，无法删除首项 
	Poly old;
	old=head;
	while(head!=NULL){
		if(head->coef==0){
			old->next=head->next;
		}
		else{old=head;
		}
		head=head->next;
	}
}
Poly find_all(Poly start,Poly C){//查找同指数的系数再加进去 
	while(start->exp!=C->exp){
		start=start->next;
	}
	start->coef=start->coef+C->coef;
	return start;//系数从高到低，记住当前位置节省时间 
}
Poly add(Poly A,Poly B){//加法并输出 
    int a,b;
    int c;//最高次 
    Poly newlist;
    Poly start;
    a=A->exp;
    b=B->exp;
    if(a>b){//再创链表，从最高次开始 
    	c=a; 
    }
    else{
    	c=b;
    }
    start=newlist=creat(c);//加法，最高次等于AB中次数最高的 
    while(A!=NULL){//循环A ,加进新表 
    	start=find_all(start,A);	
		A=A->next; 
    }
    start=newlist;
    while(B!=NULL){//循环A ,加进新表 
    	start=find_all(start,B);
		B=B->next; 
    }
    deleted(newlist);
    	if(newlist->coef==0){//防止首项为0； 
		newlist=newlist->next;
	} 
    printPolynomial(newlist);
	 
} 

Poly find_mul(int exp,int coef,Poly start){//根据系数查找，并加入新表 
	while(start->exp!=exp){
		start=start->next;
	}
	start->coef=start->coef+coef;
	return start;
}
Poly mul(Poly A,Poly B){//乘法 并输出 
	Poly head,B1=B,start;
	int a,a_exp,a_coef,exp,coef;
	a=A->exp+B->exp;
	start=head=creat(a);//创建新链表 
	while(A!=NULL){//对A多项式进行拆分，乘法分配律 
	start=head;
	B1=B;
	a_exp=A->exp;
	a_coef=A->coef;
	A=A->next;
	while(B1!=NULL){//对B进行乘法 
		exp=B1->exp+a_exp;
		coef=a_coef*B1->coef;
		start=find_mul(exp,coef,start); 
		B1=B1->next;
	}
	}
	deleted(head);
		if(head->coef==0){//防止首项为0； 
		head=head->next;
	} 
	printPolynomial(head);	
}

Poly input(){//输入 ;
	 int a;
     int b;//一组输入 
     Poly node,old;
     Poly head;
     scanf("%d %d",&a,&b);
     node=head=(Poly)malloc(sizeof(struct Node));
     while(a!=0||b!=0){
     	node->coef=a;
     	old=node;
     	node->exp=b;
     	node->next=(Poly)malloc(sizeof(struct Node));
     	node=node->next;
     	scanf("%d %d",&a,&b);
     }free(node);
     old->next=NULL;
     return head;
} 
int main(){//输入,并创建链表 
    Poly head1;
    Poly head2;
    head1=input();//第一行 
    head2=input();//第二行
    add(head1,head2); 
	printf("\n"); 
    mul(head1,head2);
} 